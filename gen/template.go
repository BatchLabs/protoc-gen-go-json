package gen

import (
	"io"
	"strings"
	"text/template"

	"github.com/golang/glog"
	"google.golang.org/protobuf/compiler/protogen"
)

// Options are the options to set for rendering the template.
type Options struct {
	EnumsAsInts        bool
	EmitDefaults       bool
	OrigName           bool
	AllowUnknownFields bool
}

// This function is called with a param which contains the entire definition of a method.
func ApplyTemplate(w io.Writer, f *protogen.File, opts Options) (bool, error) {
	if err := headerTemplate.Execute(w, tplHeader{
		File: f,
	}); err != nil {
		return false, err
	}

	return applyMessages(w, f.Messages, opts)
}

func applyMessages(w io.Writer, msgs []*protogen.Message, opts Options) (bool, error) {
	var applied bool
	for _, m := range msgs {

		if m.Desc.IsMapEntry() {
			glog.V(2).Infof("Skipping %s, mapentry message", m.GoIdent.GoName)
			continue
		}

		switch {
		case strings.HasPrefix(m.Comments.Leading.String(), "//go:marshal-as-uuid"):
			glog.V(2).Infof("Processing %s, use UUID marshaling", m.GoIdent.GoName)
			if err := uuidMessageTemplate.Execute(w, tplMessage{
				Message: m,
				Options: opts,
			}); err != nil {
				return false, err
			}

			applied = true

		default:
			glog.V(2).Infof("Skipping %s, mapentry message", m.GoIdent.GoName)
			continue
		}

		tmpApplied, err := applyMessages(w, m.Messages, opts)
		if err != nil {
			return false, err
		}
		if !applied {
			applied = tmpApplied
		}
	}

	return applied, nil
}

type tplHeader struct {
	*protogen.File
}

type tplMessage struct {
	*protogen.Message
	Options
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-json. DO NOT EDIT.
// source: {{.Proto.Name}}

package {{.GoPackageName}}

import (
	"encoding/json"
)
`))

	uuidMessageTemplate = template.Must(template.New("message").Parse(`
// MarshalJSON implements json.Marshaler
func (msg *{{.GoIdent.GoName}}) MarshalJSON() ([]byte,error) {
	var buf [38]byte
	buf[0] = '"'
	buf[len(buf)-1] = '"'

	view := buf[1 : len(buf)-1]

	var offsets = [...]int{0, 2, 4, 6, 9, 11, 14, 16, 19, 21, 24, 26, 28, 30, 32, 34}
	const hexString = "0123456789abcdef"

	for i, b := range msg.Data {
		view[offsets[i]] = hexString[b>>4]
		view[offsets[i]+1] = hexString[b&0xF]
	}
	view[8] = '-'
	view[13] = '-'
	view[18] = '-'
	view[23] = '-'

	return buf[:], nil
}

var _ json.Marshaler = (*{{.GoIdent.GoName}})(nil)
`))
)
